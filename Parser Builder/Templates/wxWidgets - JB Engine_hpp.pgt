##TEMPLATE-NAME 'wxWidgets C++ - Engine with reduce routine (Header file)'
##LANGUAGE 'wxWidgets C++'
##ENGINE-NAME 'wxWidgets C++ Engine by Jorgen Bodde'
##AUTHOR 'Jorgen Bodde' 
##FILE-EXTENSION 'h'
##NOTES
Skeleton parse header for wxWidgets C++ (tested with 
Visual Studio 6, 7 and GCC under linux)

This engine is originally (c) By Alexandre Rai, and ported
from Delphi to wxWidgets C++. wxWidgets is a cross platform
toolkit (http://www.wxwidgets.org), for Windows, Linux, 
MacOS, OS/2, Python and more!

This engine is verified and runs under Linux as well.
##END-NOTES
##ID-CASE Propercase
##ID-SEPARATOR '_'
##ID-SYMBOL-PREFIX 'Symbol'
##ID-RULE-PREFIX 'Rule'
#ifndef __GOLDPARSER_H_
#define __GOLDPARSER_H_

// Symbols
##SYMBOLS
#define %ID.Padded% %Value.Padded% // %Description%
##END-SYMBOLS

// Rules
##RULES
#define %ID.Padded% %Value.Padded% // %Description%
##END-RULES

#include "goldparser.h"

/** \class GoldParserCtrl

	This class loads the proper grammar file, and uses the wxGoldParser object to parse the grammar and call
	the reduce methods accordingly to act upon the reductions.

	Fill this class with your methods, and act upon the reduction cases, to compile your own syntax tree,
	or perform calculations of any kind. See samples in the goldparser engine code for wxWidgets for more
	clarification.
*/

class GoldParserCtrl
{
private:
	wxGoldParser *_parser;

public:
	// TODO: Create with grammar file already in place. Like GoldParserCtrl("grammar.cgt"); and
	// use GoldParserCtrl::IsOk to check op it
	
	GoldParserCtrl();
	~GoldParserCtrl();
	
	/** Sets the grammar file, and loads it. Whenever the grammar can't be loaded, the
		method returns with -1 for invalid file, and -2 for invalid grammar. if it returns
		with 0, everything is ok */
	int SetGrammarFile(const wxString &filename);

	/** Calls the parser. This will only work when there is a valid grammar file loaded.
	    It will return with 0 if the grammar was succesfully accepted, -1 means there were
	    errors */
	int Parse(const wxString &source, bool trimReductions = false, wxArrayString *messages = 0, wxArrayString *errors = 0);

	/** The heart of the parser. Every reduction is acted upon. For example when you have the reduction
	    <Result> ::= <RValue> '+' <LValue> and the <RValue>, <LValue> are numbers, you can return in the
	    current reduction something like this:

	    \code
	    // <Result> ::= <RValue> '+' <LValue>
	    case Result_RValue_Plus_LValue:
	    	R->SetTag(R->GetToken(0)->GetTag() + R->GetToken(2)->GetTag());
	    	break;

	 	// now where Result has been used in the rule, can be used to get that token back
	 	// again, like

	 	// <PrintStat> ::= print <Result>;
	 	case PrintStat_print_Result:
	 		printf("The value is %i", R->GetToken(1)->GetTag());
	 		break;

	 	// this way per reduction tree the user can act upon the current reduction and
	 	// send a value back up..

	    \endcode
	*/
	int ReplaceReduction(GpReduction *R, wxArrayString *errors = 0, wxArrayString *messages = 0);
};

#endif